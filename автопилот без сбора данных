import numpy                 # Нужна для математических функций (sqrt, exp, и т.д.)
import time                  # Нужна для задержек (sleep) и измерения времени
import krpc                  # Главная библиотека для связи с KSP через kRPC
import matplotlib.pyplot as plt  # Библиотека для построения графиков (matplotlib)
import math
###############################################################################
#                          НАСТРОЙКИ ГРАВИТАЦИОННОГО ПОВОРОТА                 #
###############################################################################

# Высота, на которой начинается гравитационный поворот (тангаж начинает меняться)
turn_start_altitude = 250      # метров над поверхностью
# Высота, на которой гравитационный поворот заканчивается (тангаж выйдет на горизонталь)
turn_end_altitude = 45000      # метров
# Желаемая конечная орбитальная высота (в данном случае для апоapsиса)
target_altitude = 80000        # метров

###############################################################################
#                          УСТАНОВКА СОЕДИНЕНИЯ С ИГРОЙ                       #
###############################################################################
# Устанавливаем соединение с KSP через kRPC
# name='Запуск на орбиту' — это просто имя сессии (можно выбрать любое)
conn = krpc.connect(name='Запуск на орбиту')
# Получаем доступ к текущему активному кораблю (ракете), которая выбрана в KSP
vessel = conn.space_center.active_vessel
###############################################################################
#                          СОЗДАНИЕ ПОТОКОВ (STREAMS) ДЛЯ ДАННЫХ             #
###############################################################################
# В KSP можно "подписаться" на некоторые параметры (как на живую телеметрию),
# чтобы не вызывать функции напрямую каждый раз, а получать данные быстрее.

# Поток UT (Universal Time) — игровое время во вселенной KSP
ut = conn.add_stream(getattr, conn.space_center, 'ut')
# Поток высоты над средним уровнем (mean_altitude) — усредненная высота над поверхностью планеты
altitude = conn.add_stream(getattr, vessel.flight(), 'mean_altitude')
# Поток значения апоапсиса орбиты (apoapsis_altitude) — максимально возможной высоты
apoapsis = conn.add_stream(getattr, vessel.orbit, 'apoapsis_altitude')
# Поток скорости (speed) — скорость корабля относительно выбранного опорного кадра
# (здесь выбран reference_frame тела, вокруг которого летим)
speed = conn.add_stream(getattr, vessel.flight(vessel.orbit.body.reference_frame), 'speed')
# Поток массы корабля (mass) — меняется при сжигании топлива, отделении ступеней и т.д.
mass = conn.add_stream(getattr, vessel, 'mass')
# Получаем объект ресурсов 5-й ступени (stage=5), чтобы следить, сколько там топлива (SolidFuel).
# cumulative=False говорит о том, что мы хотим данные только по этой ступени, а не всей ракете.
stage_5_resources = vessel.resources_in_decouple_stage(stage=5-1, cumulative=False)
# Создаём поток для количества твердого топлива (SolidFuel) в 5-й ступени (обычно это ускорители SRB).
srb_fuel = conn.add_stream(stage_5_resources.amount, 'SolidFuel')

###############################################################################
#                          СПИСКИ ДЛЯ СОХРАНЕНИЯ ДАННЫХ (ТЕЛЕМЕТРИЯ)         #
###############################################################################
time_data = []      # сюда будем записывать время (UT) на каждом шаге
altitude_data = []  # сюда будем записывать высоту
speed_data = []     # сюда будем записывать скорость
mass_data = []      # сюда будем записывать массу
###############################################################################
#                          НАСТРОЙКИ ДЛЯ ЗАПИСИ ДАННЫХ ПО ВРЕМЕНИ             #
###############################################################################
last_record_time = 0   # здесь храним последнее время, когда мы записали данные
record_interval = 0.5  # интервал в секундах, через который делаем запись данных
###############################################################################
#                          ФУНКЦИЯ ДЛЯ ЗАПИСИ ДАННЫХ                          #
###############################################################################
def record_data():
    """
    Функция, которая проверяет, прошло ли нужное количество времени
    (record_interval) с момента последней записи. Если да — записывает
    время, высоту, скорость и массу в соответствующие списки.
    """
    global last_record_time         # нужно для изменения переменной, объявленной снаружи
    current_time = ut()            # текущее игровое время
    # Проверяем, прошло ли достаточно времени с момента последней записи
    if current_time - last_record_time >= record_interval:
        time_data.append(current_time)     # записываем текущее время
        altitude_data.append(altitude())   # записываем текущую высоту
        speed_data.append(speed())         # записываем текущую скорость
        mass_data.append(mass())           # записываем текущую массу
        last_record_time = current_time    # обновляем время последней записи
###############################################################################
#                          ПРЕДСТАРТОВАЯ ПОДГОТОВКА                           #
###############################################################################

# Отключаем SAS (автоматическую систему стабилизации KSP), чтобы автопилот мог взять управление
vessel.control.sas = False

# Устанавливаем рычаг управления тягой (throttle) на максимум — 100%
vessel.control.throttle = 1.0

###############################################################################
#                          ОБРАТНЫЙ ОТСЧЁТ И СТАРТ                            #
###############################################################################

print('3...')
time.sleep(1)  # ждём 1 секунду
print('2...')
time.sleep(1)  # ещё 1 секунду
print('1...')
time.sleep(1)  # ещё 1 секунду
print('Launch!')

# Активируем первую ступень (например, может быть включение основных двигателей)
vessel.control.activate_next_stage()
# Включаем автопилот, чтобы он мог управлять углами тангажа и курса
vessel.auto_pilot.engage()
# Задаём автопилоту начальные настройки: тангаж 90°, курс 90°
# (в KSP 90° курс означает "восток", а тангаж 90° означает вертикальный взлёт)
vessel.auto_pilot.target_pitch_and_heading(90, 90)
#
###############################################################################
#                          ОСНОВНОЙ ЦИКЛ ПОЛЁТА ВВЕРХ                          #
###############################################################################

# Флаг, указывающий, что ускорители (SRB) были отделены
srbs_separated = False
# Текущий угол "гравитационного поворота"
turn_angle = 0

# Бесконечный цикл, который будет выполняться, пока мы не достигнем нужных условий
while True:
    # Сохраняем текущие телеметрические данные, если пришло время
    record_data()
    ############################################################################
    #                          ГРАВИТАЦИОННЫЙ ПОВОРОТ                          #
    ############################################################################
    # Проверяем, не пора ли начинать поворот (мы выше turn_start_altitude)
    # и ещё не поздно ли (мы ниже turn_end_altitude)
    if altitude() > turn_start_altitude and altitude() < turn_end_altitude: # если высота больше начальной 250 и концом 45000 то считаем frac
        # Считаем, какая доля пути уже пройдена между началом и концом поворота
        frac = ((altitude() - turn_start_altitude) /
                (turn_end_altitude - turn_start_altitude))
        # Угол поворота будет от 0 до 90 градусов
        new_turn_angle = frac * 90

        # Меняем угол поворота, только если изменение достаточно велико (больше 0.5 градуса)
        if abs(new_turn_angle - turn_angle) > 0.5:
            turn_angle = new_turn_angle
            # Угол тангажа мы выставляем как (90 - turn_angle), чтобы он постепенно снижался к горизонту
            vessel.auto_pilot.target_pitch_and_heading(90 - turn_angle, 90)

    ############################################################################
    #                          ОТДЕЛЕНИЕ УСКОРИТЕЛЕЙ (SRB) начало 2 ступени    #
    ############################################################################
    # Если мы ещё не отделяли SRB, проверяем остаток твёрдого топлива (srb_fuel)
    if srbs_separated == False:
        if srb_fuel() < 0.1:
            # Если топлива почти не осталось, отделяем ступень (вызов activate_next_stage)
            vessel.control.activate_next_stage()
            srbs_separated = True
            print('SRBs separated')
            vessel.control.activate_next_stage()

    ############################################################################
    #                          УПРАВЛЕНИЕ ТЯГОЙ ПРИ ДОСТИЖЕНИИ АПОАПСИСА       #
    ############################################################################
    # Проверяем, когда апоапсис приближается к 90% от целевой высоты
    # Если апоапсис (apoapsis()) > 0.9 * target_altitude, мы отключаем тягу (throttle = 0)
    if apoapsis() > target_altitude * 0.9:
        vessel.control.throttle = 0.0
        # Прерываем цикл while True, чтобы перейти к следующему этапу
        break

###############################################################################
#                          ВЫВОД НА НУЖНЫЙ АПОАПСИС                           #
###############################################################################

# Теперь, когда апоапсис достаточно высокий, приоткрываем тягу (25%),
# чтобы "дотянуть" апоапсис до точно target_altitude
vessel.control.throttle = 0.2

# Ждём, пока фактический апоапсис не станет равным (или больше) target_altitude
while apoapsis() < target_altitude:
    record_data()
    pass  # ничего дополнительно не делаем, просто крутим цикл


print('Target apoapsis reached')
# Отключаем двигатель полностью
vessel.control.throttle = 0.0

###############################################################################
#                          ПОЛЁТ ПО ИНЕРЦИИ ДО ВЫХОДА ИЗ АТМОСФЕРЫ            #
###############################################################################

print('Coasting out of atmosphere')
# Ждём, пока ракета не выйдет из атмосферы (пусть 70.5 км считается вне атмосферы — запас)
while altitude() < 71000:
    record_data()
    pass

###############################################################################
#                          ПЛАНИРОВАНИЕ МАНЁВРА ОКРУГЛЕНИЯ ОРБИТЫ             #
###############################################################################

print('Planning circularization burn')
# Гравитационный параметр (G*M) планеты (например, Кербина). Нужен для вычислений орбит.
mu = vessel.orbit.body.gravitational_parameter
# Радиус апоапсиса
r = vessel.orbit.apoapsis
# Текущий главный фокус орбиты (semi-major axis)
a1 = vessel.orbit.semi_major_axis
# Желаемая новая полуось — делаем её равной апоапсису (когда будем "округлять" орбиту)
a2 = r
# Скорость на апоапсисе до манёвра
v1 = math.sqrt(mu * ((2. / r) - (1. / a1)))
# Скорость на апоапсисе после манёвра (когда орбита станет круговой)
v2 = math.sqrt(mu * ((2. / r) - (1. / a2)))
# Разница (дельта-V) между текущей орбитальной скоростью и желаемой
delta_v = v2 - v1
# Создаём маневровый узел (Node) через vessel.control.add_node,
# ставим его выполнение через vessel.orbit.time_to_apoapsis (через время до апоапсиса).
# Указываем, что это будет манёвр prograde на delta_v.
node = vessel.control.add_node(
    ut() + vessel.orbit.time_to_apoapsis,
    prograde=delta_v
)
###############################################################################
#                          РАСЧЁТ ВРЕМЕНИ РАБОТЫ ДВИГАТЕЛЯ (BURN TIME)        #
###############################################################################

# Текущая максимальная тяга корабля (в ньютонах)
F = vessel.available_thrust
# Удельный импульс двигателя (specific impulse), умноженный на стандартную g (9.82),
# даёт нам "эффективную скорость истечения" топлива
Isp = vessel.specific_impulse * 9.82
# Начальная масса корабля
m0 = vessel.mass
# Конечная масса после сжигания delta_v, из уравнения Циолковского
m1 = m0 / math.exp(delta_v / Isp)
# Скорость сжигания топлива = Тяга / (эффективная скорость истечения)
flow_rate = F / Isp
# Время горения = (m0 - m1) / скорость расхода топлива
burn_time = (m0 - m1) / flow_rate
###############################################################################
#                          ОРИЕНТАЦИЯ КОРАБЛЯ ПЕРЕД МАНЁВРОМ                  #
###############################################################################
print('Orientating ship for circularization burn')
# Ставим систему отсчёта автопилота равной системе координат маневрового узла
vessel.auto_pilot.reference_frame = node.reference_frame
# Задаём автопилоту цель — направление на маневровый узел (вектор prograde манёвра)
# В kRPC можно так задать (0, 1, 0), но чаще используется vessel.auto_pilot.target_direction = node.direction
vessel.auto_pilot.target_direction = (0, 1, 0)

# Ждём, пока автопилот "пристроится" к нужному направлению
vessel.auto_pilot.wait()

###############################################################################
#                          ОЖИДАНИЕ ДО НАЧАЛА МАНЁВРА                         #
###############################################################################

print('Waiting until circularization burn')
# Вычисляем момент времени, когда нужно начать манёвр (берём время до апоапсиса - половина burn_time)
burn_ut = ut() + vessel.orbit.time_to_apoapsis - (burn_time / 2.)

# Небольшой запас (lead_time) в 5 секунд, чтобы занять позицию заранее и включить двигатель
lead_time = 5




# Отделяем, к примеру, пустую первую ступень (два раза вызваем activate_next_stage, т.к. может быть несколько узлов)
#vessel.control.activate_next_stage()
#vessel.control.activate_next_stage()

###############################################################################
#                          ВЫПОЛНЕНИЕ МАНЁВРА                                 #
###############################################################################

print('Ready to execute burn')
# Создаём поток, чтобы следить за временем до апоапсиса в реальном времени
time_to_apoapsis = conn.add_stream(getattr, vessel.orbit, 'time_to_apoapsis')

# Ждём, пока мы не подойдём к точке, когда осталось (burn_time/2) до апоапсиса
while time_to_apoapsis() - (burn_time / 2.) > 0:
    record_data()
    pass  # ничего не делаем, просто ждём момент зажигания

print('Executing burn')
# Наконец, включаем двигатель на полную тягу
vessel.control.throttle = 1.0

# Ждём двойное время горения (2 * burn_time), минус небольшая погрешность,
# потому что мы стартуем в середине burn_time и заканчиваем где-то в конце.
time.sleep(2 * burn_time - 0.1)

###############################################################################
#                          ДОТЮНИНГ МАНЁВРА (FINE TUNING)                     #
###############################################################################

print('Fine tuning')
# Понижаем тягу до 5%, чтобы точно "попасть" в нужную орбиту
vessel.control.throttle = 0.05

# Создаём поток для вектора оставшегося дожига (remaining_burn_vector),
# чтобы можно было посмотреть, сколько ещё "добавить" манёвра
remaining_burn = conn.add_stream(node.remaining_burn_vector, node.reference_frame)

###############################################################################
#                          ВЫПУСК СПУТНИКА (ЕСЛИ ЕСТЬ) И УДАЛЕНИЕ УЗЛА        #
###############################################################################

# Активируем следующую ступень — например, отделяем спутник
vessel.control.activate_next_stage()
vessel.control.activate_next_stage()
vessel.control.activate_next_stage()
# Удаляем (сносим) маневровый узел, т.к. он нам больше не нужен
node.remove()

print('Launch complete')

###############################################################################
#                          ПОСТРОЕНИЕ ГРАФИКОВ ПО ИТОГАМ ПОЛЁТА              #
###############################################################################

# Создаём фигуру 12 x 8 дюймов
#plt.figure(figsize=(12, 8))

###############################################################################
#                          ГРАФИК 1: ВЫСОТА                                   #
###############################################################################
#plt.subplot(3, 1, 1)            # разделяем окно на 3 строки и 1 столбец, выбираем 1-й график
#plt.plot(time_data, altitude_data, label='Altitude (m)', color='blue')  # строим линию высоты
#plt.xlabel('Time (s)')          # подпись оси X
#plt.ylabel('Altitude (m)')      # подпись оси Y
#plt.legend()                    # включаем легенду (чтобы было понятно, что за линия)

###############################################################################
#                          ГРАФИК 2: СКОРОСТЬ                                 #
###############################################################################
#plt.subplot(3, 1, 2)            # выбираем 2-й график
#plt.plot(time_data, speed_data, label='Speed (m/s)', color='green')   # скорость
#plt.xlabel('Time (s)')
#plt.ylabel('Speed (m/s)')
#plt.legend()

###############################################################################
#                          ГРАФИК 3: МАССА                                    #
###############################################################################
#plt.subplot(3, 1, 3)            # выбираем 3-й график
#plt.plot(time_data, mass_data, label='Mass (kg)', color='red')        # масса
#plt.xlabel('Time (s)')
#plt.ylabel('Mass (kg)')
#plt.legend()

# Делаем так, чтобы графики аккуратно уместились и не налезали друг на друга
#plt.tight_layout()

# Показываем окно с графиками
#plt.show()
