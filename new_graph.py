# Импортируем библиотеку numpy для работы с массивами и числовыми операциями
import numpy as np  # np – это сокращение для обращения к функциям библиотеки numpy

# Импортируем библиотеку matplotlib для построения графиков
import matplotlib.pyplot as plt  # plt используется для создания графиков и визуализации данных

# Импортируем библиотеку statistics, которая может понадобиться для статистических вычислений
import statistics  # Импортируем модуль statistics (в данном коде он не используется, но подключен на всякий случай)

# ---------------------------- ЗАДАНИЕ КОНСТАНТ И ИСХОДНЫХ ДАННЫХ ----------------------------

# Гравитационная постоянная в системе СИ (Н*м^2/кг^2)
G_global = 6.67430e-11  # Значение гравитационной постоянной

# Радиус планеты в метрах (пример для планеты Kerbin из KSP)
R_global = 600000  # Радиус планеты, м

# Масса планеты в килограммах
M_global = 5.2915158e22  # Масса планеты, кг

# Стандартное ускорение свободного падения на поверхности Земли (м/с^2)
g_earth = 9.81  # Ускорение свободного падения, м/с^2

# Диаметр ракеты в метрах
d_rocket = 5.14  # Диаметр ракеты, м

# Вычисляем площадь поперечного сечения ракеты по формуле площади круга: S = π*(d^2)/4
S_rocket = np.pi * (d_rocket ** 2) / 4.0  # Площадь поперечного сечения ракеты, м^2

# ---------------------------- ПАРАМЕТРЫ ОРБИТЫ (ИНФОРМАЦИОННЫЕ) ----------------------------

# Высота орбиты в метрах
orbitH = 80000  # Высота орбиты, м

# Вычисляем орбитальную скорость по формуле для круговой орбиты: V = sqrt(G * M / (R + H))
orbitV = np.sqrt(G_global * M_global / (R_global + orbitH))  # Орбитальная скорость на данной высоте, м/с

# ---------------------------- НАЧАЛЬНАЯ МАССА РАКЕТЫ ----------------------------

# Начальная масса ракеты в килограммах
startMass = 53000  # Стартовая масса ракеты, кг

# ---------------------------- ПАРАМЕТРЫ РАЗЛИЧНЫХ СТУПЕНЕЙ ----------------------------

# Временные интервалы работы различных ступеней (в секундах):
t0_burn = 23.7  # Время работы бустеров (работают одновременно с первой ступенью)
t1_burn = 58.4  # Время работы первой ступени после работы бустеров
t2_burn = 74.3  # Время работы второй ступени
t3_burn = 307.7  # Время работы третьей ступени

# Массовый расход топлива (в кг/с) для каждой ступени:
w_boosters = 118.71  # Расход топлива для бустеров, кг/с
w_stage1 = 68.51     # Расход топлива для первой ступени, кг/с
w_stage2 = 17.73     # Расход топлива для второй ступени, кг/с
w_stage3 = 0.65      # Расход топлива для третьей ступени, кг/с

# Полная масса бустеров (с топливом) в килограммах
boosterMass_total = 3.8 * 1000  # Общая масса бустеров, кг

# Масса топлива, содержащегося в бустерах
boosterMassFuel = 2813  # Масса топлива в бустерах, кг

# Сухая масса бустеров (без топлива)
boosterMassDry = boosterMass_total - boosterMassFuel  # Сухая масса бустеров, кг

# Полная масса первой ступени (с топливом) в килограммах
stage1Mass_total = 10.63 * 1000  # Общая масса первой ступени, кг

# Масса топлива в первой ступени
stage1MassFuel = 4000  # Масса топлива первой ступени, кг

# Сухая масса первой ступени (без топлива)
stage1MassDry = stage1Mass_total - stage1MassFuel  # Сухая масса первой ступени, кг

# Полная масса второй ступени (с топливом) в килограммах
stage2Mass_total = 1.86 * 1000  # Общая масса второй ступени, кг

# Масса топлива во второй ступени
stage2MassFuel = 1300  # Масса топлива второй ступени, кг

# Сухая масса второй ступени (без топлива)
stage2MassDry = stage2Mass_total - stage2MassFuel  # Сухая масса второй ступени, кг

# Полная масса третьей ступени (с топливом) в килограммах
stage3Mass_total = 0.7 * 1000  # Общая масса третьей ступени, кг

# Масса топлива в третьей ступени
stage3MassFuel = 200  # Масса топлива третьей ступени, кг

# Сухая масса третьей ступени (без топлива)
stage3MassDry = stage3Mass_total - stage3MassFuel  # Сухая масса третьей ступени, кг

# ---------------------------- ЗАГРУЗКА ДАННЫХ ИЗ ФАЙЛОВ KSP ----------------------------

# Открываем файл "Time.txt" для чтения временных данных
with open("Time.txt", encoding="UTF-8") as file_in:
    # Читаем содержимое файла и разделяем строку по запятой и пробелу, получая список строк
    kspTime_raw = (file_in.read()).split(', ')  # Список строк, представляющих время

# Открываем файл "Hight.txt" для чтения данных о высоте
with open("Hight.txt", encoding="UTF-8") as file_in:
    # Читаем содержимое файла, разделяем по запятой и пробелу и преобразуем каждое значение в число с плавающей точкой
    kspHeight = [float(x) for x in (file_in.read()).split(', ')]  # Список высот, м

# Открываем файл "Speed.txt" для чтения данных о скорости
with open("Speed.txt", encoding="UTF-8") as file_in:
    # Читаем содержимое файла, разделяем строку и преобразуем каждое значение в float
    kspSpeed = [float(x) for x in (file_in.read()).split(', ')]  # Список скоростей, м/с

# Открываем файл "Mass.txt" для чтения данных о массе
with open("Mass.txt", encoding="UTF-8") as file_in:
    # Читаем содержимое файла, разделяем строку и преобразуем каждое значение в float
    kspMass = [float(x) for x in (file_in.read()).split(', ')]  # Список масс, кг

# Создаем массив времени для данных KSP, используя количество элементов из kspTime_raw
kspTime = []         # Инициализируем пустой список для времени
c_counter = 0        # Инициализируем счетчик времени, начинающийся с 0
for i in range(len(kspTime_raw)):  # Проходим по каждому элементу в исходном списке времени
    kspTime.append(c_counter)      # Добавляем текущее значение счетчика в список kspTime
    c_counter += 1                 # Увеличиваем счетчик на 1 для следующей итерации

# ---------------------------- ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ МАССЫ РАКЕТЫ ----------------------------

def getMass(t):
    # Если время меньше 0, возвращаем начальную массу ракеты, так как полет еще не начался
    if t < 0:
        return startMass
    # Если время меньше или равно времени работы бустеров (первый этап), вычитаем массу сожженного топлива бустеров и первой ступени
    if t <= t0_burn:
        return startMass - w_boosters * t - w_stage1 * t
    # Вычисляем массу после отделения бустеров, вычитая массу топлива и сухую массу бустеров
    massAfterBoosters = startMass - boosterMassFuel - boosterMassDry
    # Если время меньше или равно времени работы первой ступени, после отделения бустеров, вычитаем массу топлива, сожженную первой ступенью
    if t <= t1_burn:
        return massAfterBoosters - w_stage1 * t
    # Вычисляем массу после работы первой ступени, вычитая топливо и сухую массу первой ступени
    massAfterStage1 = massAfterBoosters - stage1MassFuel - stage1MassDry
    # Если время меньше или равно суммарному времени работы первой и второй ступеней
    if t <= t1_burn + t2_burn:
        dt = t - t1_burn  # Вычисляем время работы второй ступени
        return massAfterStage1 - w_stage2 * dt  # Вычитаем массу топлива, сожженную второй ступенью
    # Вычисляем массу после работы второй ступени, вычитая топливо и сухую массу второй ступени
    massAfterStage2 = massAfterStage1 - stage2MassFuel - stage2MassDry
    # Если время находится в интервале работы третьей ступени
    if t2_burn + t1_burn < t <= t1_burn + t2_burn + t3_burn:
        dt = t - t1_burn - t2_burn  # Вычисляем время работы третьей ступени
        return massAfterStage2 - w_stage3 * dt  # Вычитаем массу топлива, сожженную третьей ступенью
    # Если время больше суммарного времени работы всех ступеней, возвращаем массу после отделения всех ступеней
    return massAfterStage2 - stage3MassDry

# ---------------------------- ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ МАССОВОГО РАСХОДА ТОПЛИВА ----------------------------

def getOmega(t):
    # Если время находится в интервале работы бустеров и первой ступени, расход топлива равен сумме их расходов
    if 0 <= t <= t0_burn:
        return w_boosters + w_stage1
    # Если время после работы бустеров, но в пределах работы первой ступени, расход топлива равен расходу первой ступени
    elif t0_burn < t <= t1_burn:
        return w_stage1
    # Если время соответствует работе второй ступени, расход топлива равен расходу второй ступени
    elif t1_burn < t <= t1_burn + t2_burn:
        return w_stage2
    # Если время соответствует работе третьей ступени, расход топлива равен расходу третьей ступени
    elif t1_burn + t2_burn < t <= t1_burn + t2_burn + t3_burn:
        return w_stage3
    # В остальных случаях (после завершения работы всех ступеней) топлива не расходуется
    else:
        return 0.0

# ---------------------------- ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ КОЭФФИЦИЕНТА ТЯГИ (Q) ----------------------------

def getQ(t):
    # Если время в интервале работы бустеров и первой ступени, коэффициент равен сумме двух значений
    if 0 <= t <= t0_burn:
        return 1667.1 + 2451
    # Если время соответствует работе первой ступени, коэффициент Q равен 3138.1
    elif t0_burn < t <= t1_burn:
        return 3138.1
    # Если время соответствует работе второй ступени, коэффициент Q равен 3383.3
    elif t1_burn < t <= t1_burn + t2_burn:
        return 3383.3
    # Если время соответствует работе третьей ступени, коэффициент Q равен 3089.1
    elif t1_burn + t2_burn < t <= t1_burn + t2_burn + t3_burn:
        return 3089.1
    # Если топливный режим завершен, коэффициент равен 0
    else:
        return 0.0

# ---------------------------- ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ УГЛА НАКЛОНА ТЯГИ (ALPHA) ----------------------------

def getAlpha(t):
    # Вычисляем угол наклона по экспоненциальной формуле, начиная с 90 градусов (pi/2 радиан) и уменьшаясь с ростом времени
    return (np.pi / 2) * np.exp(-t / 53)

# ---------------------------- ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ ЛОКАЛЬНОГО УСКОРЕНИЯ СВОБОДНОГО ПАДЕНИЯ ----------------------------

def localG(y):
    # Используем закон всемирного тяготения, где расстояние от центра планеты равно (R + y)
    return G_global * M_global / (R_global + y) ** 2

# ---------------------------- ФУНКЦИЯ, ОПРЕДЕЛЯЮЩАЯ СИСТЕМУ ОДУ (УРАВНЕНИЯ ДВИЖЕНИЯ) ----------------------------

def equations(stateVec, t):
    # Распаковываем вектор состояния: x - горизонтальная координата, y - вертикальная координата, vx и vy – соответствующие скорости
    xCoor, yCoor, vxCoor, vyCoor = stateVec  # Извлекаем отдельные компоненты вектора состояния

    # Получаем текущую массу ракеты для данного времени t с помощью функции getMass
    currentMass = getMass(t)
    # Если масса слишком мала (менее 1 кг), устанавливаем минимальное значение, чтобы избежать деления на 0
    if currentMass < 1.0:
        currentMass = 1.0

    # Вычисляем угол наклона тяги для текущего времени t
    alphaVal = getAlpha(t)
    # Вычисляем локальное ускорение свободного падения для текущей высоты yCoor
    gLocal = localG(yCoor)
    # Получаем массовый расход топлива для текущего времени
    massFlow = getOmega(t)
    # Получаем коэффициент тяги Q для текущего времени
    Qvalue = getQ(t)
    # Вычисляем общую силу тяги: F_thrust = 3 * (массовый расход топлива) * (коэффициент тяги)
    Fthrust = 3 * massFlow * Qvalue
    # Вычисляем горизонтальную компоненту силы тяги, используя косинус угла
    FthrustX = Fthrust * np.cos(alphaVal)
    # Вычисляем вертикальную компоненту силы тяги, используя синус угла
    FthrustY = Fthrust * np.sin(alphaVal)
    # Производная координаты x по времени равна текущей скорости по x
    dxDt = vxCoor
    # Если угол наклона достаточно велик (больше 0.06 рад), вертикальная скорость считается по формуле
    if alphaVal > 0.06:
        dyDt = vyCoor  # dy/dt = vy
    else:
        dyDt = 0  # Если угол слишком мал, вертикальная скорость считается равной 0 для упрощения
    # Вычисляем производную скорости по x: dvx/dt = сила по x, деленная на массу
    dvxDt = FthrustX / currentMass
    # Вычисляем производную скорости по y: dvy/dt = (сила по y / масса) минус локальное ускорение свободного падения
    if alphaVal > 0.06:
        dvyDt = (FthrustY / currentMass) - gLocal
    else:
        dvyDt = 0
    # Возвращаем список производных: [dx/dt, dy/dt, dvx/dt, dvy/dt]
    return [dxDt, dyDt, dvxDt, dvyDt]

# ---------------------------- ФУНКЦИЯ ИНТЕГРИРОВАНИЯ МЕТОДОМ РУНГЕ–КУТТЫ 4-ГО ПОРЯДКА ----------------------------

def runge_kutta4(f, state, t, dt):
    # Вычисляем k1 как значение производных в начальной точке
    k1 = np.array(f(state, t))
    # Вычисляем k2, используя k1 для оценки состояния в середине интервала
    k2 = np.array(f(state + 0.5 * dt * k1, t + 0.5 * dt))
    # Вычисляем k3, используя k2 для оценки состояния в середине интервала
    k3 = np.array(f(state + 0.5 * dt * k2, t + 0.5 * dt))
    # Вычисляем k4, используя k3 для оценки состояния в конце интервала
    k4 = np.array(f(state + dt * k3, t + dt))
    # Обновляем состояние, используя взвешенную сумму k1, k2, k3 и k4
    return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)

# ---------------------------- ОСНОВНОЙ БЛОК ПРОГРАММЫ ----------------------------
# Этот блок выполняется, если файл запущен как основной скрипт

if __name__ == '__main__':
    # Задаем начальные условия для системы: координаты (x, y) и скорости (vx, vy) равны 0
    Xinit = [0.0, 0.0, 0.0, 0.0]  # Начальное состояние: x = 0, y = 0, vx = 0, vy = 0

    # Определяем конечное время моделирования (в секундах)
    tEnd = 234.0  # Конечное время моделирования, с

    # Создаем массив временных точек от 0 до tEnd, всего 234 точки (шаг примерно 1 секунда)
    tGrid = np.linspace(0, tEnd, 234)  # np.linspace генерирует равномерно распределенные точки от 0 до tEnd

    # Инициализируем массив для хранения результатов интегрирования, размером (число временных точек) x (число переменных)
    solution = np.zeros((len(tGrid), len(Xinit)))  # Создаем двумерный массив, заполненный нулями
    solution[0] = Xinit  # Устанавливаем первое состояние равным начальному состоянию

    # Производим численное интегрирование по временной сетке методом Рунге–Кутты 4-го порядка
    for i in range(1, len(tGrid)):  # Для каждой временной точки, начиная со второй (индекс 1)
        dt = tGrid[i] - tGrid[i - 1]  # Вычисляем шаг времени как разницу между текущим и предыдущим значениями времени
        # Обновляем состояние, используя функцию runge_kutta4, передавая функции уравнений, текущее состояние, время и шаг dt
        solution[i] = runge_kutta4(equations, solution[i - 1], tGrid[i - 1], dt)

    # Извлекаем результаты интегрирования для каждой переменной:
    solX = solution[:, 0]  # Все значения координаты x из решения
    solY = solution[:, 1]  # Все значения координаты y (высота) из решения
    solVx = solution[:, 2]  # Все значения скорости по x из решения
    solVy = solution[:, 3]  # Все значения скорости по y из решения

    # Вычисляем массу ракеты для каждого момента времени в сетке tGrid
    solMass = np.array([getMass(ti) for ti in tGrid])
    # Вычисляем угол наклона тяги для каждого момента времени
    solAlpha = np.array([getAlpha(ti) for ti in tGrid])
    # Вычисляем локальное ускорение свободного падения (хотя здесь используется время, а не высота)
    solG = np.array([localG(ti) for ti in tGrid])
    # Вычисляем модуль скорости как корень суммы квадратов скоростей по x и по y
    solVel = np.sqrt(solVx ** 2 + solVy ** 2)
    # Вычисляем массовый расход топлива (омега) для каждого момента времени
    solOmega = np.array([getOmega(ti) for ti in tGrid])

    # Обрезаем данные, полученные из KSP, чтобы они содержали ровно 234 точки для сравнения с моделью
    kspSpeed = kspSpeed[:234]   # Оставляем первые 234 элемента списка скоростей
    kspMass = kspMass[:234]       # Оставляем первые 234 элемента списка масс
    kspHeight = kspHeight[:234]   # Оставляем первые 234 элемента списка высот

    # Вычисляем среднее абсолютное отклонение между моделью и данными KSP по массе
    devMass = sum(abs(kspMass[i] - solMass[i]) for i in range(len(kspMass))) / len(kspMass)
    # Вычисляем среднее абсолютное отклонение по скорости
    devSpeed = sum(abs(kspSpeed[i] - solVel[i]) for i in range(len(kspSpeed))) / len(kspSpeed)
    # Вычисляем среднее абсолютное отклонение по высоте
    devHeight = sum(abs(kspHeight[i] - solY[i]) for i in range(len(kspHeight))) / len(kspHeight)

    # Выводим средние отклонения в консоль с округлением до 3 знаков после запятой
    print(f'{round(devMass, 3)} - среднее отклонение массы')
    print(f'{round(devHeight, 3)} - среднее отклонение высоты')
    print(f'{round(devSpeed, 3)} - среднее отклонение скорости')

    # ---------------------------- ПОСТРОЕНИЕ ГРАФИКОВ ----------------------------

    # Создаем фигуру с 9 графиками, организованными в виде матрицы 3x3; размер фигуры задаем в дюймах (12 на 10)
    fig, axs = plt.subplots(3, 3, figsize=(12, 10))

    # График 1: Скорость от времени (сравнение данных KSP и модели)
    axs[0][0].plot(tGrid, kspSpeed, color='r', label='ksp')  # Строим график скоростей KSP красным цветом
    axs[0][0].plot(tGrid, solVel, label='model')             # Строим график скоростей, полученных из модели
    axs[0][0].set_xlabel("t, c")                               # Подписываем ось x как "время, с"
    axs[0][0].set_ylabel("Скорость, м/с")                      # Подписываем ось y как "скорость, м/с"
    axs[0][0].grid(True)                                       # Включаем сетку на графике
    axs[0][0].set_title("График скорости от времени")         # Задаем заголовок графика
    axs[0][0].legend()                                         # Добавляем легенду для графика

    # График 2: Масса от времени (сравнение данных KSP и модели)
    axs[0][1].plot(tGrid, kspMass, color='r', label='ksp')    # Строим график массы KSP красным цветом
    axs[0][1].plot(tGrid, solMass, label='model')              # Строим график массы из модели
    axs[0][1].set_xlabel("t, c")                               # Подписываем ось x
    axs[0][1].set_ylabel("Масса, кг")                          # Подписываем ось y
    axs[0][1].grid(True)                                       # Включаем сетку
    axs[0][1].set_title("График массы от времени")           # Задаем заголовок графика
    axs[0][1].legend()                                         # Добавляем легенду

    # График 3: Высота от времени (сравнение данных KSP и модели)
    axs[1][0].plot(tGrid, kspHeight, color='r', label='ksp')   # Строим график высоты KSP красным цветом
    axs[1][0].plot(tGrid, solY, label='model')                 # Строим график высоты из модели
    axs[1][0].set_xlabel("t, c")                               # Подписываем ось x
    axs[1][0].set_ylabel("Высота, м")                          # Подписываем ось y
    axs[1][0].grid(True)                                       # Включаем сетку
    axs[1][0].set_title("График высоты от времени")           # Задаем заголовок графика
    axs[1][0].legend()                                         # Добавляем легенду

    # График 4: Траектория движения (зависимость y от x)
    axs[1][1].plot(solX, solY)                                 # Строим график, где по оси x – координата x, по оси y – высота y
    axs[1][1].set_xlabel("x, м")                               # Подписываем ось x
    axs[1][1].set_ylabel("y, м")                               # Подписываем ось y
    axs[1][1].grid(True)                                       # Включаем сетку
    axs[1][1].set_title("Перемещение в координатной плоскости") # Задаем заголовок графика

    # График 5: Скорость по оси x от времени
    axs[2][1].plot(tGrid, solVx)                               # Строим график скорости по x, полученной из модели
    axs[2][1].set_xlabel("t, c")                               # Подписываем ось x
    axs[2][1].set_ylabel("Vx, м/с")                            # Подписываем ось y
    axs[2][1].grid(True)                                       # Включаем сетку
    axs[2][1].set_title("Скорость по x")                       # Задаем заголовок графика

    # График 6: Скорость по оси y от времени
    axs[2][0].plot(tGrid, solVy)                               # Строим график скорости по y, полученной из модели
    axs[2][0].set_xlabel("t, c")                               # Подписываем ось x
    axs[2][0].set_ylabel("Vy, м/с")                            # Подписываем ось y
    axs[2][0].grid(True)                                       # Включаем сетку
    axs[2][0].set_title("Скорость по y")                       # Задаем заголовок графика

    # График 7: Угол наклона тяги (alpha) от времени
    axs[1][2].plot(tGrid, solAlpha)                            # Строим график угла тяги, полученного из модели
    axs[1][2].set_xlabel("t, c")                               # Подписываем ось x
    axs[1][2].set_ylabel("Угол, рад")                          # Подписываем ось y
    axs[1][2].grid(True)                                       # Включаем сетку
    axs[1][2].set_title("График угла от времени")             # Задаем заголовок графика

    # График 8: Локальное ускорение свободного падения (g) от времени (упрощенно)
    axs[0][2].plot(tGrid, solG)                                # Строим график локального g (хотя g зависит от высоты, здесь используется время)
    axs[0][2].set_xlabel("t, c")                               # Подписываем ось x
    axs[0][2].set_ylabel("Ускорение, м/с^2")                   # Подписываем ось y
    axs[0][2].grid(True)                                       # Включаем сетку
    axs[0][2].set_title("График ускорения свободного падения (упрощённо)")  # Заголовок графика

    # График 9: Массовый расход топлива (омега) от времени
    axs[2][2].plot(tGrid, solOmega)                            # Строим график расхода топлива, полученного из модели
    axs[2][2].set_xlabel("t, c")                               # Подписываем ось x
    axs[2][2].set_ylabel("Омега, кг/с")                        # Подписываем ось y
    axs[2][2].grid(True)                                       # Включаем сетку
    axs[2][2].set_title("График омеги от времени")            # Заголовок графика

    # Корректируем отступы между графиками для лучшего отображения
    plt.tight_layout()

    # Отображаем все построенные графики
    plt.show()
